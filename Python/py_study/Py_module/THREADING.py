# #################################################################################################
# #################################################################################################
# """
#
# THREADING module
# 线程（Thread）：操作系统能够调度的最小执行单元，是进程中的一个独立执行流程
#
# 可以看为是一个程序的子程序
# 但是会有一定的限制
#
# """
# #################################################################################################
# """
#
# 线程的创建
# 我们主要通过 threading 模块完成
# threading.Thread 是创建线程的核心类，它提供了多种参数和方法来定制线程的行为
#
# """
# #################################################################################################
#
# import threading
# import time
#
#
#
# #通过 threading.Thread 类创建线程
# # 核心参数
# # target：指定线程要执行的函数（必填）
# # args：传递给 target 函数的位置参数（元组形式）（可选）
# # kwargs：传递给 target 函数的关键字参数（字典形式）（可选）
# # name：线程名称，默认为 Thread-N（可选 ）
# # daemon：是否为守护线程（True/False，默认为 False）（在下一节介绍）
#
# # 定义目标函数
# def mytarget(arg, kwarg = 14):
#     # threading.current_thread().name 返回当前线程的名字，如果定义了的话
#     print(f"线程{threading.current_thread().name}启动")
#     print(f"arg: {arg}, kwarg = {kwarg}")
#     time.sleep(1)
#     print(f"线程{threading.current_thread().name}结束")
#
# # 创建相关线程
# thread_1 = threading.Thread(target=mytarget,
#                             args=(11,),
#                             kwargs={"kwarg":20},name="thread_1")
# thread_2 = threading.Thread(target=mytarget,
#                             args=(15,),
#                             kwargs={"kwarg":26},name="thread_2")
#
# # 创建了但需要显式启动
# # 用 start()
# thread_1.start()
# thread_2.start()
#
# # 等待结束
# thread_1.join()
# thread_2.join()
# print("主程序结束\n-------------------------------------------")
# # 线程thread_1启动
# # arg: 11, kwarg = 20
# # 线程thread_2启动
# # arg: 15, kwarg = 26
# # 线程thread_1结束
# # 线程thread_2结束
# # 主程序结束
# # -------------------------------------------
#
# #################################################################################################
# """
#
# 守护线程
# 守护线程（Daemon Thread） 是一种特殊类型的线程，其生命周期与主线程紧密绑定
#
# 核心特点
# 主线程退出时，守护线程会立即终止，无论是否完成任务
# 不会阻止程序退出：程序在所有非守护线程结束后终止，即使守护线程仍在运行
# 适用场景：后台支持任务（如日志记录、心跳检测、监控等非关键任务）
#
# """
# #################################################################################################、
#
# import threading
# import time
#
#
#
# # 有两种设置方式
#
#
# # 守护目标函数
# def daemon_target():
#     while True:
#         print("守护进程工作中...")
#         time.sleep(1)
#
# # 非守护目标函数
# def non_daemon_target():
#     print("非守护进程工作中")
#     time.sleep(3)
#     print("非守护进程结束")
#
# # 创建守护线程
# daemon_thread = threading.Thread(target=daemon_target,daemon=True)
# # 创建非守护线程
# non_daemon_thread = threading.Thread(target=non_daemon_target)
#
# # 另一种方式就是在 start() 前对其赋值
# daemon_thread.daemon = True
#
# # 开启线程
# daemon_thread.start()
# non_daemon_thread.start()
#
# # 等待得守护线程结束
# non_daemon_thread.join()
# print("主程序结束\n-------------------------------------------")
#
# # 守护进程工作中...
# # 非守护进程工作中
# # 守护进程工作中...
# # 守护进程工作中...
# # 非守护进程结束
# # 主程序结束
# # -------------------------------------------
#
#
# # 注意：守护线程可能被突然终止，不会执行 finally 代码块或释放资源
# # 守护线程通常用于无限循环任务（如监听网络请求），但需确保主线程退出时能安全终止
# # 守护线程的任务可能随时中断，不适合保存数据或提交事务等操作
#
# #################################################################################################
# """
#
# 线程类
#
# 除了直接使用 threading.Thread 创建线程外，还可以通过继承 Thread 类来创建自定义线程
# 这种方式提供了更高的灵活性，允许将线程的行为封装到类中，从而实现更复杂的线程逻辑类
# 这种方式适合需要封装线程逻辑的复杂任务，代码更清晰且可复用
#
# 封装性：通过继承 Thread 类，可以将线程的逻辑封装到一个类中，使代码更加模块化和易于维护
# 扩展性：可以方便地添加额外的属性和方法，扩展线程的功能
# 代码复用：可以重用线程类的逻辑，创建多个线程实例
#
# """
# #################################################################################################
#
# import threading
# import time
#
#
#
# # 自定义线程类的步骤
# # 继承 threading.Thread 类
# # 重写 __init__ 方法（可选，用于传递参数）
# # 重写 run() 方法（定义线程执行的核心逻辑）
# # 启动线程：调用 start() 方法（自动触发 run()）
#
# class MyThread(threading.Thread):
#     # 可以重写__init__ 方法
#     def __init__(self, name, delay):
#         # 必须调用父类的构造函数
#         # 在这里可以将该线程设置为守护线程
#         super().__init__(daemon=True)
#         # 也可以在下面设置,效果一样
#         self.daemon = True
#         # 自定义属性
#         self.name = name
#         # 自定义参数
#         self.delay = delay
#
#     # important，线程实现逻辑，当调用 start() 是实现的逻辑
#     def run(self):
#         print(f"线程 {self.name} 启动")
#         time.sleep(self.delay)
#         print(f"线程 {self.name} 完成")
#
# # 使用自定义线程类
# thread1 = MyThread(name="Thread-A", delay=2)
# thread2 = MyThread(name="Thread-B", delay=1)
#
# # 启动线程
# thread1.start()
# thread2.start()
#
# # 等待线程结束
# thread1.join()
# thread2.join()
# print("主程序结束\n-------------------------------------------")
# # 线程 Thread-A 启动
# # 线程 Thread-B 启动
# # 线程 Thread-B 完成
# # 线程 Thread-A 完成
# # 主程序结束
# # -------------------------------------------
#
#
# # 必须重写 run() 方法来定义线程的行为。run() 方法是线程的入口点
# # 不能直接调用 run() 方法，必须通过 start() 方法启动线程
#
# #################################################################################################
# """
#
# 线程的关闭
#
# 线程的关闭是一个需要谨慎处理的操作
# 由于 Python 的线程模型（基于 CPython 的全局解释器锁 GIL）并不直接支持强制终止线程
# 突然终止线程可能导致锁未释放、文件未关闭、数据未保存等问题
# 所以 Python 的 threading 模块未提供强制终止线程的 API（设计上避免潜在风险）
# 因此关闭线程需要通过一些间接的方式实现
#
# """
# #################################################################################################
#
# import threading
# import time
#
#
#
# # 主要有
# # join()       等待线程自然结束（推荐方式）
# # Event对象    进行线程间通信来决定结束（复杂时好用）
# # Event 实现线程间通信，来控制线程的关闭（下节介绍）
#
# # join()
# # 阻塞当前线程：调用 join() 的线程（通常是主线程）
# # 会等待目标线程执行完毕，再继续执行后续代码
# # thread.join(timeout=None)
# # timeout：可选参数，指定最大等待时间（秒）
# # 超时后无论目标线程是否完成，当前线程继续执行，且父线程恢复执行
# # 返回值：None（无论是否超时）
#
# def my_task():
#     print("Thread started.")
#     time.sleep(3)  # 模拟耗时操作
#     print("Thread finished.")
#
# # 创建线程
# thread = threading.Thread(target=my_task)
# thread.start()
#
# print("Waiting for thread to finish...")
# # 等待线程结束
# thread.join()
# print("Thread has finished.")
# # Thread started.
# # Waiting for thread to finish...
# # Thread finished.
# # Thread has finished.
#
# # 设置 timeout
# def my_task():
#     print("Thread started.")
#     time.sleep(5)  # 模拟耗时操作
#     print("Thread finished.")
#
# # 创建线程
# thread = threading.Thread(target=my_task)
# thread.start()
#
# print("Waiting for thread to finish...")
# # 等待最多3秒
# thread.join(timeout=3)
# print("Thread join timeout reached.")
# # Thread started.
# # Waiting for thread to finish...
# # Thread join timeout reached.
# # Thread finished.
#
# #################################################################################################
# """
#
# Event（事件）
# threading.Event 是 Python 多线程编程中用于线程间通信的核心同步原语
# 它通过一个内部标志位实现线程的等待与唤醒机制，能够高效、安全地协调多个线程的执行顺序
#
# Event 的核心机制
# 内部标志位：Event 对象内部维护一个布尔值（初始为 False），表示某个事件是否发生
# 线程安全操作：所有方法均为原子操作，无需额外加锁
# 阻塞唤醒：线程可主动等待标志位变为 True，避免忙等待（busy waiting）消耗 CPU
#
# """
# #################################################################################################
#
# import threading
# import time
#
#
#
# #Event 的三大方法
# # set()	        将内部标志设为 True，唤醒所有等待的线程
# # clear()	    将内部标志重置为 False
# # wait(timeout)	阻塞当前线程，直到标志为 True 或超时（返回当前标志状态）
# # 若在主线程中调用 event.wait()：主线程会卡在阻塞点，直到事件被触发（event.set()）或超时
# # 若在子线程中调用 event.wait()：只有该子线程被阻塞，主线程可以继续执行其他代码
#
# # is_set()：检查内部标志是否为 True
#
#
# # 控制线程启动顺序
# # 创建 Event 对象
# start_event = threading.Event()
#
# # 目标函数，不需要将 event 丢进去
# def worker():
#     print("子线程等待启动...")
#     # 阻塞直到主线程触发事件
#     start_event.wait()
#     print("子线程开始工作")
#
# # 创建线程
# thread = threading.Thread(target=worker)
# # 启动线程
# thread.start()
#
# time.sleep(2)
# print("主线程触发启动")
# # 唤醒子线程
# start_event.set()
#
# # 等待线程结束
# thread.join()
#
# # 子线程等待启动...
# # 主线程触发启动
# # 子线程开始工作
#
#
# # 终止线程，即上面提到的关闭线程
# stop_event = threading.Event()
# def task():
#     while not stop_event.is_set():
#         print("线程运行中...")
#         time.sleep(1)
#     print("线程安全退出")
#
# thread = threading.Thread(target=task)
# thread.start()
#
# time.sleep(3)
# # 设置终止标志
# stop_event.set()
#
# thread.join()
#
#
# # 多线程同步
# # 所有子线程初始化完成后，主线程才继续执行
# def worker(ready_event, id):
#     print(f"子线程 {id} 初始化中...")
#     time.sleep(1)
#     ready_event.set()  # 标记当前线程已就绪
#     print(f"子线程 {id} 开始工作")
#
# # 创建多个线程的 Event 对象
# events = [threading.Event() for _ in range(3)]
# threads = [
#     # 将 event 与其索引一起传给参数
#     threading.Thread(target=worker, args=(event, i))
#     for i, event in enumerate(events)
# ]
#
# # 启动所有线程
# for t in threads:
#     t.start()
#
# # 主线程等待所有子线程就绪
# for event in events:
#     # 阻塞直到每个子线程的 Event 被触发
#     event.wait()
#
# print("所有子线程已就绪，主线程继续执行")

#################################################################################################
"""

锁（Lock）
在多线程编程中，锁（Lock） 是保证线程安全的核心同步机制
它用于控制对共享资源的访问，防止多个线程同时修改数据导致竞态条件（Race Condition）

锁的核心作用
互斥访问：确保同一时刻只有一个线程能进入临界区（Critical Section），保护共享资源
线程安全：防止数据不一致或损坏（如多个线程同时修改同一变量）

"""
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################
#################################################################################################