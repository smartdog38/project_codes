#PEP_8为Python 代码的样式规范
#PEP_8 的目的是为了提高代码的一致性，提高代码的可读性
#PEP_8 的规范包括：缩进、空格、换行、注释、命名、文档字符串等
#缩进一般为4个空格，且最好不用Tab键

# 命名规范
# 包和模块全小写，尽量少用_
# 类名首字母大写，驼峰命名
# 异常也是与类一样
# 函数与变量全小写，可以用_
# 始终将self作为实例方法的第一个参数
# 始终使用cls作为类方法的第一个参数
# 方法全小写，用_连接
# 常量全大写，用_连接


# 参数表对齐
# foo = long_function_name(var_one, var_two,#在第一行，竖直对齐
#                          var_three, var_four)

#if条件式里
# # No extra indentation.
# if (this_is_one_thing and
#     that_is_another_thing):
#     do_something()

# 多行结构上的右大括号/方括号/括号可以在列表最后一行的第一个非空白字符下对齐
# my_list = [
#     1, 2, 3,
#     4, 5, 6,
#     ]

# 二元运算符在之前断开
# income = (gross_wages
#           + taxable_interest
#           + (dividends - qualified_dividends)
#           - ira_deduction
#           - student_loan_interest)

# 空行
# 类与顶级函数（main）用首尾两行空行分隔，方法与函数用一行空行分隔

# 导入
# 导入应该通常应该在单独的行上
# import os
# 导入应按以下顺序分组
# 标准库导入
# 相关的第三方
# 特定于本地应用程序/库的导入
# 简单来说就是系统自带库->第三方库->自己写的库
# 应该在每组导入之间放置一个空行
# 最好避免使用from module import *，会导致导入不清


# 模块级 dunder 变量（跟在docstring即模块的文档字符串后）
# __all__ 模块级变量，用于控制从模块导入*时导入的对象
# __version__ 模块级变量，用于记录模块的版本
# __author__ 模块级变量，用于记录模块的作者
# 但from __future__ import 要放在这些变量之前，这是为了引入比当前所用的Python版本更新的语法

# 空格使用
# 紧挨在括号、方括号或大括号内
# spam(ham[1], {eggs: 2})
# 在尾随逗号和后面的右括号之间
# foo = (0,)
# 紧接在逗号、分号或冒号之前
# if x == 4: print(x, y); x, y = y, x
# 但是，在切片中，冒号的作用类似于二进制运算符，并且两侧的量应相等，可以两边不空
# a[1:2]
# 紧接在启动函数调用的参数列表的左括号之前
# spam(1)
# 紧接在开始索引或切片的左括号之前
# dct['key'] = lst[index]
# 赋值（或其他）运算符周围有一个空格
# x = 1
# 但有多个运算符时可以根据运算优先级来更改
# x = x*2 - 1
# 当用于指示关键字参数或用于指示未注释的函数参数的默认值时， = 不要在符号周围使用空格
# def complex(real, imag=0.0):
#     return magic(r=real, i=imag)
# 但是，当将参数注释与默认值组合在一起时，在 = 符号周

# 一般不使用复合语句，即同一行上有多个语句
# if foo == 'blah':
#     do_blah_thing()

# 尾随逗号
# 尾随逗号通常是可选的，但在创建一个元素的 Tuples 时它们是强制性的
# FILES = ('setup.cfg',)
# 将每个值（等）单独放在一行上，始终添加尾随逗号，并在下一行添加右括号/方括号/大括号。
# FILES = [
#     'setup.cfg',
#     'tox.ini',
#     ]

# 注释
# 注释应该是完整的句子,第一个单词应该大写
# 在多句子注释中，应该在句子结束句点后使用 1 个或 2 个空格，但最后一个句子之后除外
# 行内注释应与语句至少相隔两个空格。它们应以 # 和一个空格开头。（最好少用）
# 块注释
# 适用于它们后面的某些 （或全部） 代码，并且缩进到与该代码相同的级别。块注释的每一行都以一个"#"
# 和一个空格开头（除非它是注释内的缩进文本）。

# 函数注释
# def f(x: int) -> bool: # 这是一个函数注释，表明返回值为bool类型，输入为int类型
# 变量注释
# a: int = 1 # 这是一个变量注释


# 良好文档字符串（又名“docstrings”）
# 文档字符串是作为模块、函数、类或方法定义中的第一个语句出现的字符串文本。
# 所有模块通常都应该有文档字符串，并且模块导出的所有函数和类也应该有文档字符串。
# 公共方法（包括 __init__ 构造函数）也应该有文档字符串
# 在模块、类或 __init__ 方法的顶层进行简单赋值后立即出现的字符串文字称为“属性文档字符串”。
# 紧跟在另一个文档字符串之后出现的字符串文字称为“附加文档字符串”。

# 内用接口与公共接口
# __all__ 属性 是一个 字符串列表，该列表中的元素是模块的公共接口（API）的名字。
# 任何列在 __all__ 中的名字都会被 导出
# __all__=['add','sub']
# 只有两个函数、类或变量能被导入
# 写进的都是稳定的能被外界用的，可以向后发展兼容的，而没写的只有在该模块中使用的
# 导入的库自己导入的模块，不需要在你的模块里再导入（即不需要实现细节）

# 最好要"".join()来拼接字符串，而不是用+，减少时间复杂度
# 想 None 这样的单例使用 is or is not
# 用 is not 而不是 not ... is 来判断
# 弃用 lambda ，用：def f(x): return 2*x
# with管理上下文最好单独管理文件，而不能在里面实现功能
# 任何函数里要么都有返回值（若不需要返回None），要么都没有
# 用 startwith 与 endwith 来检查前缀与后缀
# 用 isinstance 来比较两个对象的类型isinstance(obj1, type) 而不是 type(obj1) == type(obj2)
# 空序列为False
# 不拿 bool 值与 True 与 False 值比较，直接 if greeting:

