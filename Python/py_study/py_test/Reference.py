#################################################################################################
#################################################################################################
"""

引用
引用是指变量与对象之间的关联关系
Python 中的变量本质上是对对象的引用，而不是直接存储对象的值
分为强引用与弱引用
变量本身并不存储对象的值，而是存储对象的引用（内存地址）
多个变量可以引用同一个对象

"""
#################################################################################################
"""

引用对象

"""
#################################################################################################

# 可变对象的引用
# 对象的值可以修改
a = [1, 2, 3]  # a 引用了一个列表对象
b = a          # b 引用了与 a 相同的列表对象
b.append(4)    # 修改 b 也会影响 a
print(a)       # 输出: [1, 2, 3, 4]


# 不可变对象的引用
# 对象的值不可修改，如果尝试修改，会创建一个新对象
a = 10  # a 引用整数对象 10
b = a   # b 引用与 a 相同的对象
a = 20  # a 引用一个新的整数对象 20
print(b)  # 输出: 10 (b 仍然引用原来的对象)

#################################################################################################
"""

函数的参数引用
在 Python 中，函数参数的传递是通过引用传递的
这意味着函数内部的操作可能会影响外部对象

"""
#################################################################################################

def modify_list(lst):
    lst.append(4)  # 修改传入的列表

a = [1, 2, 3]
modify_list(a)
print(a)  # 输出: [1, 2, 3, 4]

#################################################################################################
"""

引用的比较
在 Python 中，== 和 is 用于比较对象：
==：比较对象的值是否相等。
is：比较对象的引用是否相同（是否指向同一个对象）

"""
#################################################################################################

a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(a == b)  # 输出: True (值相等)
print(a is b)  # 输出: False (引用不同)
print(a is c)  # 输出: True (引用相同)

#################################################################################################
"""

拷贝
分为浅拷贝与深拷贝
浅拷贝只复制对象本身，不复制对象内部的子对象
深拷贝复制对象及其所有子对象

"""
#################################################################################################

# 浅拷贝
# 使用 copy.copy() 或对象的 copy() 方法
import copy

a = [1, 2, [3, 4]]
b = copy.copy(a)  # 浅拷贝
b[2].append(5)    # 修改子对象会影响原对象
print(a)          # 输出: [1, 2, [3, 4, 5]]


# 深拷贝
# 使用 copy.deepcopy()
import copy

a = [1, 2, [3, 4]]
b = copy.deepcopy(a)  # 深拷贝
b[2].append(5)        # 修改子对象不会影响原对象
print(a)              # 输出: [1, 2, [3, 4]]

#################################################################################################
"""

引用的销毁
当对象的引用计数为 0 时，对象会被垃圾回收器销毁

"""
#################################################################################################

import sys

a = [1, 2, 3]
print(sys.getrefcount(a))  # 输出: 2 (a 和 getrefcount 的参数各有一个引用)
b = a
print(sys.getrefcount(a))  # 输出: 3 (a, b 和 getrefcount 的参数各有一个引用)
del b
print(sys.getrefcount(a))  # 输出: 2 (b 的引用被删除)

#################################################################################################
"""

弱引用（weakref）
我们之前申明的所有都为强引用，即会增加对象的引用计数
只要引用不销毁，那么引用对象就不会被垃圾回收器（Garbage Collector, GC）回收
而弱引用是一种特殊的引用方式，它不会增加对象的引用计数
这意味着，如果一个对象只有弱引用指向它，而没有强引用
那么该对象可以被垃圾回收器回收

Python 的弱引用机制依赖于对象的可哈希性和可变性
不支持弱引用的类型
- 不可变的内置类型：int、str、float、bool 等
- 可变的内置类型：list、dict、set 等
支持弱引用的类型
- 用户自定义的类实例
- 某些不可变类型（如 tuple）在某些情况下支持弱引用

"""
#################################################################################################

# Python 提供了 weakref 模块来支持弱引用。常用的类和函数包括：
# weakref.ref(obj)：创建一个弱引用对象
# weakref.WeakValueDictionary：键是强引用，值是弱引用的字典
# weakref.WeakKeyDictionary：键是弱引用，值是强引用的字典
# weakref.WeakSet：元素是弱引用的集合

# weakref.ref(obj)
import weakref

class MyClass:
    pass

obj = MyClass()
ref = weakref.ref(obj)
print(ref())  # <__main__.MyClass object at 0x...>
# 删除强引用
del obj
print(ref())  # None

# weakref.WeakValueDictionary
import weakref

class MyClass:
    pass

# 创建 WeakValueDictionary
weak_dict = weakref.WeakValueDictionary()
obj = MyClass()
# 添加键值对
weak_dict['key'] = obj
print(weak_dict['key'])  # <__main__.MyClass object at 0x...>
# 删除强引用
del obj
print(weak_dict.get('key'))  # None

#################################################################################################